<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ES6 최신문법</title>
    </head>
    <body>
        <h1>ES6 Javascript 최신 문법</h1>
        <textarea cols="150" rows="100">

            1. 모던 자바스크립트, 모던 신텍스, 최신 문법 등으로 이야기 한다
            2. ES 란? ECMAScript의 약자이고, 자바스크립트의 표준, 규격을 나타내는 용어. 자동차로 친다면 모델명 정도
            3. 모든 언어는 업데이트를 한다. 처음부터 완벽하게 만들어서 나오진 않기 때문. 그 중에 가장 핫했던 업데이트가 ES6 이다
            4. 뒤에 숫자는 버전을 나타낸다. ES4 -> ES5(2009)-> ES6(2015)
            5. 문법을 나타내면 다음과 같다
            -템플릿 리터럴
                1. 사용법은 백틱` 으로 한다
                2. `ES6 최신문법을 사용하는 나는 $(myName)이다`

                ES5
                var str1 = ', ';
                var str2 = 'World!';
                var str3 = 'Hello' + str1 + str2;
                
                ES6
                let str1 = ', ';
                let str2 = 'World!';
                let str3 = `Hello ${str1} ${str2}`;

            -객체 리터럴
                1. 이전 문법보다 훨씬 간결해진 코드로 객체를 선언할 수 있다
                2. 메소드에 더이상 콜론(:) 이나 function을 붙이지 않아도 된다
                3. 함수명이 겹치는 경우에는 한번만 쓸 수 있다
                4. 객체의 프로퍼티를 동적으로 생성하려면 객체 리터럴 바깥에서 [text + 1] 과 같이 선언했어야 했었다
                5. ES6 부터는 객체 안에서 바로 속성으로 사용할 수 있게 되었다

                const myFn = function(){
                    console.log('myFn');
                };
                const text = 'TEXT';
                const obj = {
                    inside(){
                        console.log('객체 안에 바로 함수를 선언');
                    },
                    myFn,
                    [text + 1] : '프론트엔드'
                };
                obj.inside();           //출력값 : 객체 안에 바로 함수 선언
                obj.myFn();             //출력값 : myFn
                console.log(obj.TEXT1); //출력값 : 프론트엔드


            -화살표 함수 (arrow function)
                1. 함수 표현식을 화살표 함수로 표현 할 수 있다
                2. 화살표 함수가 추가되어 함수를 간결하게 나타낼 수 있게 되어 가독성 및 유지 보수성이 올라갔다
                3. 만약 함수의 본문에 return 만 있는 경우 화살표 함수는 return과 {}를 생략할 수 있다. 단, 둘이 같이 생략해야 함
                4. return문에서 소괄호는 사용 가능

                    ES5
                    function plusFn(a, b){
                        return a+b;
                    };

                    ES6
                    // 함수 표현식 - 화살표 함수, arrow function
                    const plusFn = (a, b) => {
                        return a+b;
                    }

                    //함수 표현식 - 화살표 함수 (생략형)
                    const plusFn = (a, b) => a + b;

                    const 함수이름 = () => {}

                5. 일반함수에는 있지만 화살표함수에는 없는 것. this 키워드
                    - this 란? this는 나, 본인, 자기자신, 지금 이거!
                    
                    //this 예제
                    let age = 30;
                    let person = {
                        name : '홍길동',
                        age : 20,
                        getInfo : function(){
                            console.log(age)
                        }
                    }
                    person.getInfo()


                    // 전역변수 age 말고, 객체 안에 있는 age를 불러들이기 위해 this를 사용
                    let age = 30;
                    let person = {
                        name : '홍길동',
                        age : 20,
                        getInfo : function(){
                            console.log(this.age)
                        }
                    }
                    person.getInfo()

                    //객체 안에 함수를 arrow function 으로 바꾸면?
                    let age = 30;
                    let person = {
                        name : '홍길동',
                        age : 20,
                        getInfo : () => {
                            console.log(this.age) //Undefined 문구가 콘솔에 나온다
                        }
                    }
                    <!-- Undefined : 변수는 존재하나, 어떠한 값으로도 할당되지 않아 자료형이 정해지지(undefined) 않은 상태 -->
                    person.getInfo()
                6. arrow function 에서 this는 나를 불러준 함수 또는 객체, 기타등등이 포함 되어 있는 가장 최상위의 공간을 this로 인식
                let age = 30;
                let person = {
                    name : '홍길동',
                    age : 20,
                    getInfo : () => {
                        console.log(this)
                    }
                }
                person.getInfo()
                7. 위의 함수 안에 this 생성 방식을 렉시컬스코프 (lexical scope) 라고 한다
                    
                8. 함수가 포함된 영역을 가리키는 상황이 필요하다면 일반함수를 사용하고 그게 아니라면 화살표함수를 사용하면 된다
                //화살표 함수는 익명함수로만 사용할 수 있다 스스로 this를 생성할 수 없다. this는 일반함수에서만 사용 가능
                //일반 함수에서 this는 함수가 어떻게 호출 되는지에 따라 this 바인딩이 동적으로 결정되는데,
                //화살표함수는 this가 정적으로 결정 된다. 언제나 상위 스코프의 this를 가리킨다
                
            -변수 선언 키워드
                1. 기존에 사용되던 변수 선언의 키워드는 var 이다
                2. 추가된 키워드 let과 const
                3. 블로스코프를 가지고 재선언 불가 재할당 가능한 let 변수 선언 키워드
                4. 상수 선언 키워드 const 추가 됨
                5. 기존의 var 키워드만 있었을 때 보다 예측 가능한 코드를 작성할 수 있게 됐다

            -모듈(Module)
                1. 모듈이란 재사용하기 위한 코드의 조각을 뜻한다
                2. 세부사항은 캡슐화 시키고, API 부분만 외부에 노출시킨 코드이다
                3. type에 module을 추가시키고, 확장자를 mjs로 변경하여 사용한다
                4. 모듈은 모듈스코프를 가지며, import와 export 키워드를 이용하여 사용한다
                    <!-- <script type="module" src="lib.msj"></script> -->


            -구조 분해 할당
                1. 구조 분해 할당이란 펼치다 라는 뜻
                2. 객체나 배열에서 사용
                3. 값을 해체한 후 개별 값을 변수에 새로 할당하는 과정
                    //배열에서 Spread 사용
                    const arr = [1,2,3];
                    const [one, two, three] = arr;
                    one     //1
                    two     //2
                    three   //3

                    //객체에서 Spread 사용
                    const obj = {
                        firstName : '프론트'
                        lastName: '엔드'
                    };
                    const {firstName, lastName} = obj;
                    firstName   //프론트 
                    lastName    //엔드

                4. 객체 초기화 방법
                    let name = "SoYoung"
                    let age=20
                    위의 데이터들을 가지고, 객체를 만든다면 다음과 같았다
                    let person = {이름: name , 나이: age}
                    바뀐 방법으로 만들면 다음과 같다
                    let person = {name, age}

        </textarea>
        <script>
            /* function pooh() {
                console.log('곰돌이 푸우');
            } */

            /* let pooh = () => {
                console.log('곰돌이 푸우');
            };

            pooh(); */

            /* function pooh() {
                return '푸우는 꿀을 좋아해';
            }
            console.log(pooh()); */

            /* let pooh = () => '푸우는 꿀을 좋아해!!';
            console.log(pooh()); */

            /*             let age = 30;
            let person = {
                name: '홍길동',
                age: 20,
                getInfo: function () {
                    console.log(age);
                },
            };
            person.getInfo(); */

            /*             let age = 30;
            let person = {
                name: '홍길동',
                age: 20,
                getInfo: function () {
                    console.log(this.age);
                },
            };
            person.getInfo(); */

            //화살표 함수는 익명함수로만 사용할 수 있다 스스로 this를 생성할 수 없다. this는 일반함수에서만 사용 가능
            //일반 함수에서 this는 함수가 어떻게 호출 되는지에 따라 this 바인딩이 동적으로 결정되는데,
            //화살표함수는 this가 정적으로 결정 된다. 언제나 상위 스코프의 this를 가리킨다

            let 이름 = 'SoYoung';
            let 나이 = 20;
            let person = { 이름, 나이 };
            console.log(person);
        </script>
    </body>
</html>
